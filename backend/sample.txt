 " \n \n \n课  程  设  计 \n \n \n \n \n \n \n课程设计名称：操作系统原理课程设计 \n专 业 班 级 ：     计科2304 班       \n学 生 姓 名 ：       刘家辉        \n学       号 ：    231040100409    \n指 导 教 师 ：        李爽         \n课程设计时间：2025.6.23—2025.6.28  \n \nI \n计算机科学与技术专业   操作系统原理课程设计  任务书 \n学生姓名 \n刘家辉 \n专业班级 \n计科2304 \n学号 \n231040100409 \n题  目 \n动态优先权进程调度算法 \n课题性质 \n其它 \n课题来源 \n自拟课题 \n指导教师 \n李爽 \n同组姓名 \n无 \n主要内容 \n1、用C 语言来实现对N 个进程采用动态优先权优先算法的进程调度。 \n2、每个用来标识进程的进程控制块PCB 用结构来描述，包括以下字段： \n进程标识数ID； \n进程优先数PRIORITY，并规定优先数越大的进程，其优先权越高； \n进程已占用的CPU 时间CPUTIME； \n进程还需占用的CPU 时间ALLTIME。 \n3、当进程运行完毕时，ALLTIME 变为0；进程的阻塞时间STARTBLOCK，表\n示当进程再运行STARTBLOCK 个时间片后，进程将进入阻塞状态；进程被阻\n塞的时间BLOCKTIME，表示已阻塞的进程再等待BLOCKTIME 个时间片后，\n进程将转换成就绪状态；进程状态STATE；队列指针NEXT，用来将PCB 排成\n队列。 \n3、优先数改变的原则： \n进程在就绪队列中呆一个时间片，优先数增加1； \n进程每运行一个时间片，优先数减3。 \n任务要求 \n1、通过算法的模拟加深对进程概念和进程调度过程的理解，掌握进程状态之\n间的切换，同时掌握进程调度算法的实现方法和技巧。 \n2、分析设计要求，给出解决方案（要说明设计实现所用的原理、采用的数据\n结构）。 \n3、设计合适的测试用例，对得到的运行结果要有分析。 \n4、总结设计中遇到的问题，完成心得体会。 \n5、能够在设计过程中撰写规范的设计报告，在设计完成后通过答辩。 \n参考文献 \n王红玲等.计算机操作系统实验指导[M].人民邮电出版社,2021. \n朱敏等.操作系统课程设计[M].机械工业出版社, 2021. \n刘刚等.操作系统实验教程[M].科学出版社, 2019. \n郁红英等.计算机操作系统实验指导[M].清华大学出版社, 2018. \n何嘉等.操作系统实验指导——基于Linux 内核[M].清华大学出版社, 2016. \n审查意见 \n指导教师签字： \n教研室主任签字：                          2025 年6 月22 日  \nII \n  目   录   \n \n1 需求分析 .................................................................................. 1 \n1.1 系统功能需求 ........................................................................... 1 \n1.2 开发分工说明 ........................................................................... 1 \n2 概要设计 .................................................................................. 3 \n2.1 核心算法设计 ........................................................................... 3 \n2.2 存储结构设计 ........................................................................... 3 \n2.3 函数模块设计 ........................................................................... 5 \n3 运行环境 .................................................................................. 6 \n4 开发工具和编程语言 ........................................................................ 7 \n5 详细设计 .................................................................................. 8 \n5.1 核心数据结构定义 ....................................................................... 8 \n5.2 调度核心函数实现 ....................................................................... 9 \n5.3 主循环与调度流程实现 .................................................................. 11 \n6 调试分析 ................................................................................. 15 \n6.1 测试数据设计 .......................................................................... 15 \n6.2 设计与调试中的问题及解决方案 .......................................................... 15 \n6.3 算法的改进设想 ........................................................................ 16 \n7 测试结果 ................................................................................. 18 \n7.1 测试方案与初始状态 .................................................................... 18 \n7.2 运行过程与结果分析 .................................................................... 18 \n参考文献 ................................................................................... 21 \n心得体会 ................................................................................... 22 \n1 \n1 需求分析 \n1.1 系统功能需求 \n本次实验的核心目标是设计并实现一个基于动态优先权策略的进程调度模拟程序。该程序\n旨在模拟现代操作系统中多道程序环境下处理器调度的基本过程，通过具体的编程实践，加深\n对进程作为系统资源分配基本单位的理解，并深入探究进程在不同状态（就绪、运行、阻塞）\n之间转换的内在机制与触发条件。实验要求使用C 语言作为开发语言，以确保程序运行的效率\n和对底层数据结构的精确控制。 \n为实现上述目标，系统需要对多个并发进程进行管理。每个进程由一个进程控制块（Process \nControl Block, PCB）作为其在系统中的唯一标识和信息载体。根据设计要求，PCB 需以结构体\n（struct）形式定义，其内部必须包含以下关键字段：进程标识数（ID），用于唯一区分各个进\n程；进程优先数（PRIORITY），一个整型数值，其值越大代表该进程的调度优先级越高；进程\n已占用CPU 时间（CPUTIME），记录进程累计运行的时长；进程还需占用的CPU 时间\n（ALLTIME），表示进程完成其全部任务所需的剩余时间，当此值为0 时，标志着进程执行完\n毕。此外，PCB 还需包含控制进程状态转换的字段：进程的阻塞启动时间（STARTBLOCK），\n定义了进程在累计运行多少个时间片后将进入阻塞状态；进程被阻塞的时长（BLOCKTIME），\n规定了处于阻塞状态的进程需要等待多少个时间片才能重新返回就绪状态；进程状态（STATE），\n用于标记进程当前所处的具体状态；以及队列指针（NEXT），该指针用于将所有PCB 连接成一\n个或多个队列，是实现进程调度队列管理的基础。 \n本实验的调度算法核心在于优先权的动态调整机制，旨在平衡处理器的利用效率与进程调\n度的公平性。该机制遵循两条基本原则：首先，为了防止高优先级进程持续占用CPU 而导致低\n优先级进程“饿死”，所有处于就绪队列中等待的进程，每经过一个时间片，其优先数（PRIORITY）\n自动增加1；其次，为了体现进程运行所消耗的系统资源，任何进程每在处理器上成功运行一\n个时间片，其优先数（PRIORITY）将减少3。这一增一减的动态调整策略，使得等待时间较长\n的进程有机会提升其优先级，从而获得被调度的机会，是整个调度模拟系统的灵魂所在。 \n1.2 开发分工说明 \n本次课程设计的所有工作均由本人独立完成。整个项目的生命周期，从前期的需求解读与\n分析，到中期的概要设计包括核心算法流程的规划、数据结构的选择与定义），再到后期的详细\n2 \n设计与编码实现（包括所有函数的编写、调试与优化），以及最终的测试数据设计、结果分析和\n本实验报告的撰写，均由个人独立承担。通过独立完成项目全周期工作，旨在全面锻炼和检验\n个人在软件开发、问题分析与解决方面的综合能力。 \n \n \n \n \n \n \n \n \n \n \n3 \n2 概要设计 \n2.1 核心算法设计 \n本模拟系统的核心算法旨在精确模拟一个基于时间片的动态优先权进程调度过程。整个调\n度程序由一个主循环驱动，该循环以单个时间片为步进单位，持续运行直至系统中所有进程都\n执行完毕，即当就绪队列与阻塞队列均为空时，循环终止。在每个独立的时间片内，算法严格\n按照以下逻辑顺序执行，以确保调度的确定性和正确性。 \n首先，算法对阻塞队列进行处理。系统会遍历当前阻塞队列中的所有进程，将其内部的阻\n塞倒计时长（BLOCKTIME）减一。在遍历过程中，实时检查每一个进程的BLOCKTIME 值，\n若有进程的该值减至零，则意味着其阻塞状态结束，系统会立即将其从阻塞队列中移除，更新\n其状态为就绪态，并将其插入到就绪队列的末尾，等待下一轮的调度。 \n其次，当阻塞队列处理完毕后，算法进入CPU 调度阶段。程序会扫描整个就绪队列，通过\n比较队列中所有进程的优先数（PRIORITY），查找并确定当前拥有最高优先权的进程。若存在\n多个进程拥有相同的最高优先数，则遵循“先来先服务”的原则，选择最先进入就绪队列的进程\n（在本设计中即为链表中位置最靠前的那个）作为本时间片的运行进程。选定后，该进程将从\n就绪队列中被移除。 \n接着，进入进程执行与状态更新环节。被选中的进程状态被设置为运行态，其系统属性将\n根据动态优先权算法规则进行更新：代表其优先权的PRIORITY 值减3，记录其已运行时间的\nCPUTIME 值加1，同时其剩余运行时间ALLTIME 值减1。与此同时，为了体现对等待进程的\n补偿机制，所有仍在就绪队列中等待的进程，其PRIORITY 值均增加1，以此提升它们在后续\n调度中被选中的概率。 \n最后，对刚刚执行完毕的进程进行状态判断与迁移。系统会检查该进程的ALLTIME 值，\n若该值等于零，则说明进程已完成所有任务，其状态将被置为完成态，并被移入完成队列。若\n进程未结束，则进一步检查其是否满足阻塞条件，即其CPUTIME 值是否等于预设的\nSTARTBLOCK 值，若满足，则进程状态转为阻塞态，并被插入阻塞队列。如果进程既未完成\n也未触发阻塞，它将被重新置为就绪态并插回就绪队列，参与未来的调度竞争。若在某一时间\n片开始时，就绪队列为空但阻塞队列不为空，则该时间片内CPU 将处于空闲状态。 \n2.2 存储结构设计 \n4 \n为了有效管理进程信息，本次设计严格遵循题目要求，采用C 语言的结构体（struct）来定\n义进程控制块（PCB），该结构体封装了描述一个进程所需的所有核心数据。该存储结构的设计\n是整个系统的基石，其具体的C 语言定义如下所示： \nC \ntypedef enum { \n    READY, \n    RUNNING, \n    BLOCKED, \n    FINISHED \n} State; \n \ntypedef struct PCB { \n    int ID; \n    int PRIORITY; \n    int CPUTIME; \n    int ALLTIME; \n    int STARTBLOCK; \n    int BLOCKTIME; \n    State STATE; \n    struct PCB *NEXT; \n} PCB; \n在上述定义中，State 为一个枚举类型，用于清晰地表示进程的四种可能状态。在PCB 结\n构体内部，各字段严格对应需求分析中的各项数据。特别地，struct PCB *NEXT 指针是实现进\n程队列管理的关键。 \n由于进程在不同状态间的转换导致其需要频繁地在不同队列中移入和移出，采用静态数组\n等结构进行管理效率低下且实现复杂。因此，本设计选用链式存储结构，即链表，来组织和管\n理就绪队列、阻塞队列及完成队列。系统中定义了三个全局的PCB 指针，ready_q、blocked_q\n5 \n和finished_q，它们分别作为三个队列的头指针。当一个进程的状态发生改变时，仅需通过修改\n相关节点的NEXT 指针，即可高效地将其从一个链表（队列）中摘下，并挂载到另一个链表（队\n列）中，具有极高的灵活性和执行效率。 \n2.3 函数模块设计 \n为实现程序的结构化和模块化，便于开发、调试与维护，整个模拟程序被划分为一系列功\n能明确的函数模块。每个函数负责一项具体的任务，通过主函数main 进行统一的调用和协同。 \nvoid init_processes()：该函数无参数，负责在程序启动时进行初始化工作。它根据实验要求\n的初始数据，创建全部5 个进程的PCB，为每个PCB 的各个字段赋初值，并将它们全部插入到\n就绪队列中，为模拟调度做好准备。 \nvoid insert_to_ready(PCB *p)、void insert_to_blocked(PCB *p)、void insert_to_finished(PCB \n*p)：这是一组功能类似的队列插入函数。它们接收一个指向待插入PCB 的指针p 作为参数，\n分别负责将该进程插入到就绪队列、阻塞队列或完成队列的队尾，并更新其状态为相应的\nREADY、BLOCKED 或FINISHED。 \nPCB* get_highest_priority_process()：此函数是调度算法的核心实现之一。它遍历全局的就\n绪队列ready_q，查找到具有最大PRIORITY 值的进程，将其从就绪队列链表中移除，并返回一\n个指向该进程PCB 的指针。 \nvoid print_queue(PCB *queue, const char *name)：这是一个辅助性的打印函数，用于显示单\n个队列的当前状态。它接收一个队列的头指针和队列名称字符串作为参数，遍历并打印出队列\n中每个进程的关键信息，便于调试和结果观察。 \nvoid print_all_status(int time_slice, PCB* running_p)：这是一个综合性的状态报告函数。它在\n每个时间片结束时被调用，通过内部调用print_queue 等函数，格式化地输出当前时间片编号、\n正在运行的进程信息、以及就绪、阻塞和完成三个队列的完整内容，为分析调度过程提供了直\n观的数据展现。 \nint main()：作为程序的入口和主控制函数，main 负责整个模拟流程的编排。它首先调用\ninit_processes 进行初始化，然后进入主循环，在每个循环中按2.1 节所述的算法逻辑依次调用\n其他函数模块来处理阻塞队列、选取和执行进程、更新各进程状态，并打印最终结果，直至所\n有进程执行完毕。 \n6 \n3 运行环境 \n本次实验的开发与运行均在一个基于x86_64 架构的硬件平台上完成。该平台具体为一台云\n服务器虚拟机，配备了主频为2.4GHz 的中央处理器（CPU）核心，分配了4GB 的系统运行内\n存（RAM），以及50GB 的固态硬盘（SSD）存储空间，硬件配置足以满足本次模拟程序的编译\n与运行需求。 \n软件环境方面，操作系统选用的是稳定且广泛使用的Ubuntu Server 22.04 LTS 64 位版本。\n该系统为程序的开发和测试提供了一个标准的、兼容性强的Linux 环境，所有代码的编译、执\n行和调试工作均在操作系统自带的GNU Bash 命令行Shell 环境中完成，未依赖任何图形化用户\n界面。 \n \n7 \n4 开发工具和编程语言 \n本实验项目采用C 语言作为唯一的编程语言。具体遵循C11 标准进行代码编写，以利用其\n较为现代的语法特性并保证代码的规范性和可移植性。C 语言具有执行效率高、对内存控制精\n确的优点，非常适合用于实现操作系统底层功能的模拟。 \n开发工具链完全基于GNU 项目。核心的编译工作由GNU Compiler Collection（GCC）的\n9.4.0 版本完成，该编译器将C 语言源代码编译为本地可执行文件。在代码编写阶段，主要使用\n运行于命令行环境下的Vim 文本编辑器，它功能强大且资源占用低，能够满足快速开发的需求。\n整个开发过程不涉及任何集成开发环境（IDE），完全在Linux 终端下通过命令行工具协作完成。 \n \n8 \n5 详细设计 \n本章节将展示动态优先权进程调度模拟器的核心源代码实现。代码遵循结构化编程思想，\n通过模块化函数实现特定功能。为突出重点，此处仅列出与核心数据结构、调度算法和主控制\n流程最相关的函数代码，并对关键部分添加了注释说明。 \n5.1 核心数据结构定义 \n系统的所有操作都围绕进程控制块（PCB）展开，它是描述进程状态和属性的基础。PCB\n通过C 语言的结构体进行定义，同时使用枚举类型State 来增强代码的可读性，明确表示进程\n所处的四种基本状态。 \nC \n/* \n * 使用枚举类型定义进程的四种状态，增强代码可读性。 \n * READY: 就绪态，等待被CPU 调度 \n * RUNNING: 运行态，正在占用CPU \n * BLOCKED: 阻塞态，因等待某事件而暂停 \n * FINISHED: 完成态，进程已执行完毕 \n */ \ntypedef enum { \n    READY, \n    RUNNING, \n    BLOCKED, \n    FINISHED \n} State; \n \n/* \n * 进程控制块 (PCB) 结构体定义，是系统中进程的唯一标识。 \n * 它封装了进程调度所需的全部信息。 \n */ \n9 \ntypedef struct PCB { \n    int ID;             // 进程的唯一标识符 \n    int PRIORITY;       // 进程当前优先数，数值越大优先级越高 \n    int CPUTIME;        // 进程已经占用CPU 的时间片总数 \n    int ALLTIME;        // 进程完成任务总共需要的时间片 \n    int STARTBLOCK;     // 进程累计运行此数目的时间片后将进入阻塞态 (-1 表示不\n阻塞) \n    int BLOCKTIME;      // 进程进入阻塞态后需要等待的时间片总数 \n    State STATE;        // 枚举类型，表示进程当前的状态 \n    struct PCB *NEXT;   // 指针，用于将PCB 链接成队列（如就绪队列、阻塞队列） \n} PCB; \n5.2 调度核心函数实现 \nget_highest_priority_process 函数是调度算法的核心体现。该函数负责遍历当前的就绪队列，\n依据“优先数最大者优先”的原则，找出最应该被调度的进程。在找到该进程后，函数会将其从\n就绪队列链表中安全地移除，并返回指向该进程PCB 的指针，供主程序后续执行。 \nC \n/* \n * 函数功能：从就绪队列中找出并移除优先级最高的进程。 \n * 返回值：返回一个指向被选中进程PCB 的指针；若就绪队列为空，则返回NULL。 \n */ \nPCB* get_highest_priority_process() { \n    // 如果就绪队列为空，则直接返回NULL，表示无进程可调度 \n    if (ready_q == NULL) { \n        return NULL; \n    } \n \n    // 初始化关键指针 \n10 \n    PCB *highest_p = ready_q;      // 临时变量，假设队列的第一个进程优先级最高 \n    PCB *prev = NULL;              // 指向当前遍历节点的前一个节点 \n    PCB *current = ready_q;        // 指向当前正在遍历的节点 \n    PCB *prev_highest = NULL;      // 指向最高优先级节点的前一个节点 \n \n    // 第一次遍历：查找拥有最高优先级的进程节点 \n    while (current != NULL) { \n        if (current->PRIORITY > highest_p->PRIORITY) { \n            // 如果当前进程的优先级更高，则更新记录 \n            highest_p = current; \n            prev_highest = prev; \n        } \n        // 移动指针，继续遍历下一个节点 \n        prev = current; \n        current = current->NEXT; \n    } \n \n    // 从链表中移除最高优先级的进程节点 \n    // 关键操作：修改指针链接，将目标节点从链表中“摘除” \n    if (highest_p == ready_q) { \n        // 情况一：如果最高优先级进程是队列的头节点 \n        ready_q = ready_q->NEXT; \n    } else { \n        // 情况二：如果最高优先级进程是队列的中间或尾部节点 \n        prev_highest->NEXT = highest_p->NEXT; \n    } \n     \n11 \n    // 断开被移除节点的next 指针，使其成为一个独立的节点，防止产生野指针 \n    highest_p->NEXT = NULL; \n    return highest_p; \n} \n5.3 主循环与调度流程实现 \n程序的主体部分位于main 函数中的一个while 循环。该循环以时间片为单位驱动整个模拟\n过程，完整地实现了2.1 节所描述的调度算法流程，包括处理阻塞进程、选择并执行进程、更\n新所有进程状态和属性等。 \nC \n// main 函数中的主循环部分，是整个调度的驱动核心 \nwhile (ready_q != NULL || blocked_q != NULL) { \n    time_slice++; // 时间片计数器加1 \n \n    /* \n     * 步骤一：处理阻塞队列中的所有进程 \n     * 每个阻塞进程的BLOCKTIME 减1，若减至0 则将其唤醒，移入就绪队列。 \n     */ \n    if (blocked_q != NULL) { \n        PCB *p = blocked_q; \n        PCB *prev = NULL; \n        while (p != NULL) { \n            p->BLOCKTIME--; // 阻塞时间倒计时 \n            if (p->BLOCKTIME <= 0) { \n                PCB *to_ready = p; // 待唤醒的进程 \n                // 从阻塞队列移除 \n                if (p == blocked_q) { \n                    blocked_q = p->NEXT; \n12 \n                } else { \n                    prev->NEXT = p->NEXT; \n                } \n                p = p->NEXT; // 指针移动到下一个节点 \n                insert_to_ready(to_ready); // 将唤醒的进程插入就绪队列 \n            } else { \n                prev = p; \n                p = p->NEXT; \n            } \n        } \n    } \n \n    /* \n     * 步骤二：从就绪队列选择一个进程来运行 \n     * 调用核心调度函数获取当前最高优先级的进程。 \n     */ \n    PCB *running_p = get_highest_priority_process(); \n \n    if (running_p != NULL) { // 如果就绪队列不为空，即有进程可执行 \n        /* * 步骤三：执行进程并根据调度规则更新其属性 \n         */ \n        running_p->STATE = RUNNING; \n        running_p->PRIORITY -= 3;   // 运行一个时间片，优先级减3 \n        running_p->CPUTIME += 1; \n        running_p->ALLTIME -= 1; \n \n        /* \n13 \n         * 步骤四：更新就绪队列中所有等待进程的优先级 \n         * 这是动态优先级算法的关键补偿机制。 \n         */ \n        PCB *p_ready = ready_q; \n        while (p_ready != NULL) { \n            p_ready->PRIORITY += 1; // 等待一个时间片，优先级加1 \n            p_ready = p_ready->NEXT; \n        } \n         \n        /* \n         * 步骤五：判断刚运行完毕的进程的下一状态 \n         */ \n        if (running_p->ALLTIME <= 0) { \n            // 情况一：进程已完成全部任务 \n            insert_to_finished(running_p); \n        } else if (running_p->STARTBLOCK != -1 && running_p->CPUTIME == \nrunning_p->STARTBLOCK) { \n            // 情况二：进程触发阻塞事件 \n            insert_to_blocked(running_p); \n        } else { \n            // 情况三：进程未完成也未阻塞，返回就绪队列 \n            insert_to_ready(running_p); \n        } \n    } else { \n        // 如果就绪队列为空，则当前时间片CPU 空闲 \n        printf(\"--- Time Slice %d: CPU is IDLE ---\\n\", time_slice); \n    } \n14 \n     \n    // 步骤六：打印当前时间片结束时所有队列的详细状态，用于调试和结果分析 \n    print_all_status(time_slice, NULL); \n} \n \n15 \n6 调试分析 \n6.1 测试数据设计 \n为全面验证本模拟调度系统的正确性和健壮性，本次调试采用了一组精心设计的初始进程\n数据作为核心测试用例。该测试数据集包含了五个初始状态和资源需求各不相同的进程，能够\n有效地覆盖动态优先权调度过程中的多种典型情景，如高低优先级进程的初始竞争、进程优先\n级的动态升降、普通进程的执行以及特定进程的阻塞与唤醒等。采用此组数据，旨在系统性地\n检验程序是否准确实现了预定的调度策略。具体的初始进程状态参数如表1 所示： \n表1 初始进程状态参数 \n进程标识数 (ID) \n0 \n1 \n2 \n3 \n4 \n进程优先数 (PRIORITY) \n9 \n38 \n30 \n29 \n0 \n已占用CPU 时间 (CPUTIME) \n0 \n0 \n0 \n0 \n0 \n还需占用CPU 时间 (ALLTIME) \n3 \n3 \n6 \n3 \n4 \n进程阻塞启动时间 (STARTBLOCK) \n2 \n-1 \n-1 \n-1 \n-1 \n进程被阻塞的时长 (BLOCKTIME) \n3 \n0 \n0 \n0 \n0 \n初始状态 (STATE) \nREADY READY READY READY READY \n6.2 设计与调试中的问题及解决方案 \n在程序的详细设计与编码实现过程中，遇到了一些典型的问题，通过细致的分析和调试，\n这些问题均得到了有效的解决。 \n第一个主要问题出现在对队列的链表操作上，尤其是在get_highest_priority_process 函数中\n移除最高优先级进程节点的逻辑。初版代码在处理指针时不够严谨，未充分考虑到待移除节点\n可能是链表头节点这一特殊情况。这导致在某些场景下，当就绪队列的第一个进程就是最高优\n先级进程时，程序无法正确更新队列的头指针，从而引发链表断裂，造成后续的队列遍历和访\n问错误。解决方案是对移除逻辑进行重构，增加了对目标节点是否为头节点的判断。若目标是\n头节点，则直接将队列的头指针指向原头节点的下一个节点；若为非头节点，则通过一个额外\n记录的前驱指针（prev_highest）来修改其NEXT 域，从而安全、正确地将目标节点从链表中剥\n离。 \n第二个关键问题是关于进程状态转换的逻辑顺序。在早期的代码实现中，对一个刚运行完\n16 \n时间片的进程，程序先判断其是否满足阻塞条件，后判断其是否已经执行完毕。这一顺序存在\n逻辑缺陷，当一个进程在其最后一个时间片恰好也满足了阻塞条件时（例如，ID 为0 的进程总\n共需要运行3 个时间片，其阻塞触发时间为2，若将其ALLTIME 改为2，则在CPUTIME 为2\n时，它既完成了也满足了阻塞），它会被错误地移入阻塞队列而非完成队列。为修正此问题，调\n整了状态判断的if-else 分支顺序，确保程序总是优先检查进程是否完成（ALLTIME <= 0）。只\n有在进程未完成的前提下，才继续判断其是否需要阻塞，从而保证了进程状态转换的唯一性和\n正确性。 \n第三个调试中发现的问题是优先级的更新时机不当。在一次迭代中，曾错误地将“为就绪队\n列中等待的进程增加优先级”的操作放在了“将刚运行完的进程插回就绪队列”之后。这导致了刚\n运行完的进程在返回就绪队列的瞬间，其优先级也被错误地增加了1，这违背了“运行即消耗，\n等待即补偿”的设计原则。解决方案是严格规范主循环中的操作次序：首先从就绪队列中取出待\n运行进程，然后对就绪队列中所有剩余的进程执行优先级增加操作，最后再处理被取出的进程，\n根据其执行结果决定其下一个归属队列。通过明确各操作步骤的界限，确保了调度规则被精确\n执行。 \n6.3 算法的改进设想 \n在当前实现的基础上，本调度算法仍有进一步优化和扩展的空间，以适应更复杂的调度需\n求。 \n首先，可以优化对优先级相同进程的处理机制。当前实现对优先级相同的进程采用的是隐\n式的“先来先服务”策略，即选择链表中位置靠前的进程。可以引入一个二级调度规则作为补充，\n例如，在优先级相同的情况下，优先选择“剩余运行时间最短”（Shortest Remaining Time）的进\n程。这种改进能够潜在地优化系统的平均周转时间和等待时间，但需要相应地在\nget_highest_priority_process 函数中增加额外的比较逻辑。 \n其次，可以引入更为复杂的优先级调整策略。当前的优先级增减值（+1，-3）是固定的，\n这在某些场景下可能不是最优解。可以设计一种自适应的调整机制，例如，根据系统中进程的\n平均等待时间或CPU 的负载情况，动态地调整优先级的增减幅度。此外，还可以为不同类型（如\nI/O 密集型或CPU 密集型）的进程设置不同的优先级调整方案，以实现更加精细化的服务质量\n（QoS）控制。 \n17 \n最后，一个更具挑战性的改进是引入资源和锁的概念，以模拟和解决“优先级反转”问题。\n在真实的操作系统中，一个高优先级进程可能会因等待一个被低优先级进程持有的资源而被迫\n阻塞。本算法可以扩展PCB 结构以包含其正在等待或持有的资源列表，并实现“优先级继承”协\n议。当发生上述阻塞时，暂时将持有资源的低优先级进程的优先级提升至等待它的高优先级进\n程的级别，使其能尽快执行并释放资源，从而避免系统性能的严重下降。 \n \n18 \n7 测试结果 \n7.1 测试方案与初始状态 \n本测试旨在验证动态优先权进程调度模拟程序的功能完整性与逻辑正确性。对以下几个关\n键行为进行验证：1) 调度器在初始状态下是否正确选择了最高优先级的进程；2) 进程在运行\n和等待过程中的优先级是否按照预定规则（运行减3，等待加1）进行动态调整；3) 特定进程\n（ID 为0）能否在满足条件时正确地从运行态转换到阻塞态，并在阻塞时间结束后被成功唤醒\n返回就绪态；4) 所有进程最终能否全部正常结束并进入完成队列。 \n7.2 运行过程与结果分析 \n程序启动后，首先对所有进程进行初始化，并打印时间片0 的系统状态。程序的实际运行\n输出截图如图1 所示： \n \n图1 时间片0 时的运行状态截图 \n分析：从初始状态可以看出，全部5 个进程均已成功创建并被放入就绪队列，其各项参数\n与设计的测试数据完全一致。系统初始化模块工作正常。 \n在第一个时间片，系统从就绪队列中选择优先级最高的进程投入运行。程序的实际运行输\n出截图如图2 所示： \n \n图2 时间片1 时的运行状态截图 \n分析：ID 为1 的进程因其拥有最高的初始优先级38 而被调度程序选中运行。运行一个时\n间片后，其优先级降低为35（38-3），剩余运行时间（AllTime）变为2。与此同时，所有在就\n绪队列中等待的进程（ID 0, 2, 3, 4）的优先级均增加了1。此结果验证了调度选择和动态优先级\n调整规则的正确性。 \n19 \n随着调度的进行，ID 为0 的进程在累计运行了2 个时间片后，触发了阻塞事件。程序的实\n际运行输出截图如图3 所示： \n \n图3 ID 为0 的进程进入阻塞队列 \n分析：在第8 个时间片，ID 为0 的进程（在其第2 次运行时）的CPUTime 达到了其\nSTARTBLOCK 值2，因此在执行完毕后，它被正确地移入了阻塞队列。其在阻塞队列中的\nBLOCKTIME 将从预设值3 开始倒计时。这证明了进程由运行态到阻塞态的转换机制已成功实\n现。 \n在ID 为0 的进程阻塞3 个时间片之后，它被成功唤醒。程序的实际运行输出截图如图4\n所示： \n \n图4 ID 为0 的进程从阻塞队列返回就绪队列 \n分析：在第10 个时间片结束时，ID 为0 的进程的BLOCKTIME 倒计时结束。因此在第11\n个时间片开始时，它已从阻塞队列中移除，并重新回到了就绪队列中，其状态正确无误。这证\n明了进程从阻塞态到就绪态的唤醒机制工作正常。 \n经过19 个时间片的运行，所有进程均执行完毕。程序的最终运行输出截图如图5 所示： \n \n图5 运行结束时的最终状态 \n分析：最终，就绪队列和阻塞队列均为空，所有5 个进程都已进入完成队列，且它们的\n20 \nALLTIME 值均为0。程序的结束语也成功打印。这表明整个调度模拟过程顺利完成，所有进程\n都得到了正确的处理，系统最终达到了一个稳定、正确的终止状态。综上所述，本次测试结果\n充分验证了所设计的动态优先权进程调度程序的正确性和可靠性。 \n21 \n参考文献 \n[1]中科海微(北京)科技有限公司.一种linux内核的进程调度方法、装置及电子设备: 20241159974\n7.3[P].2025-04-11.  \n[2]徐云龙,李莉,圣文顺.操作系统原理[M].南京大学出版社:202206.201.  \n[3]徐小龙.现代操作系统教程[M].人民邮电出版社:202201.198.  \n[4]王红玲,褚晓敏.计算机操作系统实验指导[M].人民邮电出版社:202112.174.  \n[5]刘玓,陈佳,肖堃,等.Linux操作系统应用编程[M].人民邮电出版社:202104.262.  \n[6]孟庆昌,张志华.操作系统原理[M].机械工业出版社:202104.715. \n22 \n心得体会 \n通过本次动态优先权进程调度算法的课程设计，我将操作系统课堂上学到的理论知识与具\n体的编程实践紧密地结合了起来，整个过程虽然充满挑战，但收获颇丰。这不仅是一次简单的\n编码任务，更是一次对操作系统核心原理的深度探索与验证。 \n在本次实验之前，我对进程、进程控制块（PCB）、进程状态（就绪、运行、阻塞）以及调\n度算法的理解，大多停留在书本的抽象概念层面。通过亲手设计PCB 结构体，我才真正具体地\n理解了操作系统是如何封装和管理一个进程的所有信息，PCB 无愧于进程的“身份证”。当我在\n代码中实现将一个PCB 节点从就绪队列链表移动到阻塞队列链表时，课本上那个抽象的状态转\n换图瞬间变得生动而具体。我不再是旁观者，而是亲手设计并导演了进程的整个生命周期，这\n种体验是单纯的理论学习无法比拟的。 \n实践的过程也让我深刻认识到理论与现实之间的差距，以及编程实现的严谨性要求。C 语\n言中指针的操作是本次实验的一大难点。链表作为管理动态队列的理想数据结构，其节点的插\n入、特别是删除操作，对指针的运用要求极高。在调试过程中，我多次因为指针处理不当，例\n如忘记处理头节点删除的特殊情况或修改了错误的前驱节点指针，导致链表断裂或内存访问错\n误。反复的调试和修正过程，极大地锻炼了我细致、严谨的编程思维，也让我对C 语言的内存\n管理机制有了更深的敬畏和理解。此外，对调度逻辑中细节的把握也至关重要，例如，对运行\n完毕的进程，是先判断其是否完成还是先判断其是否阻塞，这一微小的顺序差异直接关系到程\n序逻辑的正确性，让我体会到算法设计的精妙与严苛。 \n更重要的是，本次实验培养了我分析、设计并解决一个小型系统级问题的综合能力。从最\n初的需求分析，到选择合适的数据结构和算法，再到模块化的函数设计，以及为了追踪程序行\n为而编写的日志打印函数（print_all_status），每一步都是对系统思维能力的一次锻炼。我学会\n了如何将一个宏观的系统（进程调度）分解为一系列可操作、可实现、可验证的微观步骤。通\n过观察低优先级进程（如ID 为4 的进程）如何在等待中逐步提升优先级并最终获得CPU，我\n直观地理解了动态优先级算法在维护系统公平性、防止进程“饿死”方面所扮演的重要角色。 \n总而言之，本次课程设计是一次极具价值的实践。它不仅巩固了我对操作系统进程调度核\n心概念的理解，显著提升了我的C 语言编程和调试能力，更让我学会了如何将抽象的理论模型\n转化为具体、可靠的计算机程序。这次经历为我后续学习更为复杂的操作系统知识乃至其他计\n23 \n算机科学领域的知识，打下了坚实的基础。 \n"